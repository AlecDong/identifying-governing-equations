"""
Equation Discovery Module using PySINDy

This module uses PySINDy (Sparse Identification of Nonlinear Dynamics) to discover
governing equations from time-series data generated by both the ODE and SimPy models.
"""

import numpy as np
import pandas as pd
import pysindy as ps
from scipy.integrate import odeint
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, r2_score


class EquationDiscovery:
    """
    PySINDy-based equation discovery for fluid queue systems.
    
    This class applies SINDy to learn the governing equations from time-series data
    and compares the discovered equations with the true underlying dynamics.
    """
    
    def __init__(self, threshold=0.01, alpha=0.05, max_iter=20):
        """
        Initialize the equation discovery system.
        
        Parameters:
        -----------
        threshold : float
            Sparsity threshold for SINDy
        alpha : float
            Regularization parameter
        max_iter : int
            Maximum iterations for SINDy optimization
        """
        self.threshold = threshold
        self.alpha = alpha
        self.max_iter = max_iter
        
        # SINDy model
        self.model = None
        
        # Discovered equations
        self.discovered_equations = None
        self.feature_names = None
        self.coefficients = None
        
        # Training data
        self.X_train = None
        self.t_train = None
        self.X_dot_train = None
        
    def prepare_data(self, data_df, dt=None, smoothing_window=5):
        """
        Prepare data for SINDy analysis.
        
        Parameters:
        -----------
        data_df : pandas.DataFrame
            DataFrame with columns: time, x, y
        dt : float, optional
            Time step. If None, computed from data
        smoothing_window : int
            Window size for smoothing derivatives
            
        Returns:
        --------
        X : ndarray
            State variables [x, y]
        X_dot : ndarray
            Time derivatives [dx/dt, dy/dt]
        t : ndarray
            Time vector
        """
        # Sort by time to ensure proper ordering
        data_df = data_df.sort_values('time').reset_index(drop=True)
        
        t = data_df['time'].values
        X = data_df[['x', 'y']].values
        
        # Compute time step if not provided
        if dt is None:
            dt = np.mean(np.diff(t))
        
        # Compute derivatives using finite differences
        X_dot = np.gradient(X, dt, axis=0)
        
        # Apply smoothing to derivatives if requested
        if smoothing_window > 1:
            from scipy.ndimage import uniform_filter1d
            X_dot = uniform_filter1d(X_dot, size=smoothing_window, axis=0)
        
        # Remove NaN values that might arise from differentiation
        valid_indices = ~(np.isnan(X).any(axis=1) | np.isnan(X_dot).any(axis=1))
        
        return X[valid_indices], X_dot[valid_indices], t[valid_indices]
    
    def fit_sindy_model(self, X, X_dot, t=None, feature_library=None):
        """
        Fit SINDy model to the data.
        
        Parameters:
        -----------
        X : ndarray
            State variables
        X_dot : ndarray
            Time derivatives
        t : ndarray, optional
            Time vector
        feature_library : pysindy library, optional
            Feature library to use
            
        Returns:
        --------
        model : pysindy.SINDy
            Fitted SINDy model
        """
        # Default polynomial feature library
        if feature_library is None:
            feature_library = ps.PolynomialLibrary(degree=2, include_bias=True)
        
        # Create SINDy model
        self.model = ps.SINDy(
            optimizer=ps.STLSQ(threshold=self.threshold, alpha=self.alpha, 
                              max_iter=self.max_iter),
            feature_library=feature_library,
            differentiation_method=ps.FiniteDifference()
        )
        
        # Fit the model
        self.model.fit(X, t=t, x_dot=X_dot)
        
        # Store training data
        self.X_train = X.copy()
        self.X_dot_train = X_dot.copy()
        self.t_train = t.copy() if t is not None else None
        
        # Extract discovered equations
        self.discovered_equations = self.model.equations()
        try:
            self.feature_names = self.model.get_feature_names()
        except:
            # Fallback for older PySINDy versions
            self.feature_names = ['x', 'y']
        self.coefficients = self.model.coefficients()
        
        return self.model
    
    def predict_derivatives(self, X):
        """
        Predict derivatives using the discovered model.
        
        Parameters:
        -----------
        X : ndarray
            State variables
            
        Returns:
        --------
        X_dot_pred : ndarray
            Predicted derivatives
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        return self.model.predict(X)
    
    def simulate_discovered_system(self, initial_state, t_eval):
        """
        Simulate the system using discovered equations.
        
        Parameters:
        -----------
        initial_state : array_like
            Initial conditions [x(0), y(0)]
        t_eval : array_like
            Time points for evaluation
            
        Returns:
        --------
        solution : ndarray
            Solution of the discovered system
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        solution = self.model.simulate(initial_state, t_eval)
        return solution
    
    def compare_with_true_system(self, true_params, initial_state, t_eval):
        """
        Compare discovered system with true system.
        
        Parameters:
        -----------
        true_params : dict
            True system parameters (lambda_arrival, mu_service, etc.)
        initial_state : array_like
            Initial conditions
        t_eval : array_like
            Time points for evaluation
            
        Returns:
        --------
        comparison_results : dict
            Comparison metrics and data
        """
        # Simulate true system
        def true_system(state, t):
            x, y = state
            x = max(0, x)
            y = max(0, y)
            
            effective_service = true_params['mu_service'] * min(x, true_params['N_capacity'])
            dx_dt = true_params['lambda_arrival'] - effective_service + true_params['gamma_return'] * y
            dy_dt = true_params['p_return'] * effective_service - true_params['gamma_return'] * y
            
            return [dx_dt, dy_dt]
        
        true_solution = odeint(true_system, initial_state, t_eval)
        
        # Simulate discovered system
        try:
            discovered_solution = self.simulate_discovered_system(initial_state, t_eval)
        except Exception as e:
            print(f"Warning: Could not simulate discovered system: {e}")
            discovered_solution = np.zeros_like(true_solution)
        
        # Calculate metrics
        mse_x = mean_squared_error(true_solution[:, 0], discovered_solution[:, 0])
        mse_y = mean_squared_error(true_solution[:, 1], discovered_solution[:, 1])
        
        r2_x = r2_score(true_solution[:, 0], discovered_solution[:, 0])
        r2_y = r2_score(true_solution[:, 1], discovered_solution[:, 1])
        
        return {
            'time': t_eval,
            'true_solution': true_solution,
            'discovered_solution': discovered_solution,
            'mse_x': mse_x,
            'mse_y': mse_y,
            'r2_x': r2_x,
            'r2_y': r2_y,
            'total_mse': mse_x + mse_y,
            'avg_r2': (r2_x + r2_y) / 2
        }
    
    def compare_with_training_data(self, X_train, t_train, time_grid):
        """
        Compare discovered system with training data.
        
        Parameters:
        -----------
        X_train : ndarray
            Training state variables
        t_train : ndarray
            Training time vector
        time_grid : ndarray
            Time points for simulation
            
        Returns:
        --------
        comparison_results : dict
            Comparison metrics and data
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        # Simulate discovered system from initial training state
        initial_state = X_train[0]
        discovered_solution = self.simulate_discovered_system(initial_state, time_grid)
        
        # Interpolate training data to the simulation time grid
        from scipy.interpolate import interp1d
        interp_func_x = interp1d(t_train, X_train[:, 0], kind='linear', fill_value="extrapolate")
        interp_func_y = interp1d(t_train, X_train[:, 1], kind='linear', fill_value="extrapolate")
        
        x_train_interp = interp_func_x(time_grid)
        y_train_interp = interp_func_y(time_grid)
        
        # Calculate metrics
        mse_x = mean_squared_error(x_train_interp, discovered_solution[:, 0])
        mse_y = mean_squared_error(y_train_interp, discovered_solution[:, 1])
        
        r2_x = r2_score(x_train_interp, discovered_solution[:, 0])
        r2_y = r2_score(y_train_interp, discovered_solution[:, 1])
        
        return {
            'time': time_grid,
            'training_data': np.column_stack((x_train_interp, y_train_interp)),
            'discovered_solution': discovered_solution,
            'mse_x': mse_x,
            'mse_y': mse_y,
            'r2_x': r2_x,
            'r2_y': r2_y,
            'total_mse': mse_x + mse_y,
            'avg_r2': (r2_x + r2_y) / 2
        }
    
    def plot_comparison(self, comparison_results, figsize=(15, 10)):
        """
        Plot comparison between true and discovered systems.
        
        Parameters:
        -----------
        comparison_results : dict
            Results from compare_with_true_system
        figsize : tuple
            Figure size
        """
        fig, axes = plt.subplots(2, 3, figsize=figsize)
        
        t = comparison_results['time']
        true_sol = comparison_results['true_solution']
        disc_sol = comparison_results['discovered_solution']
        
        # Plot x trajectories
        axes[0, 0].plot(t, true_sol[:, 0], 'b-', linewidth=2, label='True System')
        axes[0, 0].plot(t, disc_sol[:, 0], 'r--', linewidth=2, label='Discovered System')
        axes[0, 0].set_title(f'Server Level x(t)\nR² = {comparison_results["r2_x"]:.4f}')
        axes[0, 0].set_xlabel('Time')
        axes[0, 0].set_ylabel('x(t)')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)
        
        # Plot y trajectories
        axes[0, 1].plot(t, true_sol[:, 1], 'b-', linewidth=2, label='True System')
        axes[0, 1].plot(t, disc_sol[:, 1], 'r--', linewidth=2, label='Discovered System')
        axes[0, 1].set_title(f'Return Level y(t)\nR² = {comparison_results["r2_y"]:.4f}')
        axes[0, 1].set_xlabel('Time')
        axes[0, 1].set_ylabel('y(t)')
        axes[0, 1].legend()
        axes[0, 1].grid(True, alpha=0.3)
        
        # Phase portraits
        axes[0, 2].plot(true_sol[:, 0], true_sol[:, 1], 'b-', linewidth=2, label='True System')
        axes[0, 2].plot(disc_sol[:, 0], disc_sol[:, 1], 'r--', linewidth=2, label='Discovered System')
        axes[0, 2].set_title('Phase Portrait Comparison')
        axes[0, 2].set_xlabel('x(t)')
        axes[0, 2].set_ylabel('y(t)')
        axes[0, 2].legend()
        axes[0, 2].grid(True, alpha=0.3)
        
        # Error plots
        error_x = true_sol[:, 0] - disc_sol[:, 0]
        error_y = true_sol[:, 1] - disc_sol[:, 1]
        
        axes[1, 0].plot(t, error_x, 'g-', linewidth=2)
        axes[1, 0].set_title(f'Error in x(t)\nMSE = {comparison_results["mse_x"]:.6f}')
        axes[1, 0].set_xlabel('Time')
        axes[1, 0].set_ylabel('Error')
        axes[1, 0].grid(True, alpha=0.3)
        
        axes[1, 1].plot(t, error_y, 'g-', linewidth=2)
        axes[1, 1].set_title(f'Error in y(t)\nMSE = {comparison_results["mse_y"]:.6f}')
        axes[1, 1].set_xlabel('Time')
        axes[1, 1].set_ylabel('Error')
        axes[1, 1].grid(True, alpha=0.3)
        
        # Combined error
        total_error = np.sqrt(error_x**2 + error_y**2)
        axes[1, 2].plot(t, total_error, 'm-', linewidth=2)
        axes[1, 2].set_title(f'Total Error\nAvg R² = {comparison_results["avg_r2"]:.4f}')
        axes[1, 2].set_xlabel('Time')
        axes[1, 2].set_ylabel('Total Error')
        axes[1, 2].grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig
    
    def assess_model_quality(self, X_test, X_dot_test):
        """
        Assess quality of the discovered model on test data.
        
        Parameters:
        -----------
        X_test : ndarray
            Test state variables
        X_dot_test : ndarray
            Test derivatives
            
        Returns:
        --------
        metrics : dict
            Quality assessment metrics
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        # Predict derivatives
        X_dot_pred = self.predict_derivatives(X_test)
        
        # Calculate metrics
        mse_x = mean_squared_error(X_dot_test[:, 0], X_dot_pred[:, 0])
        mse_y = mean_squared_error(X_dot_test[:, 1], X_dot_pred[:, 1])
        
        r2_x = r2_score(X_dot_test[:, 0], X_dot_pred[:, 0])
        r2_y = r2_score(X_dot_test[:, 1], X_dot_pred[:, 1])
        
        # Model complexity (number of non-zero coefficients)
        complexity = np.sum(np.abs(self.coefficients) > self.threshold)
        
        return {
            'derivative_mse_x': mse_x,
            'derivative_mse_y': mse_y,
            'derivative_r2_x': r2_x,
            'derivative_r2_y': r2_y,
            'total_derivative_mse': mse_x + mse_y,
            'avg_derivative_r2': (r2_x + r2_y) / 2,
            'model_complexity': complexity,
            'sparsity_ratio': 1 - (complexity / self.coefficients.size)
        }
