"""
Equation Discovery Module using PySINDy

This module uses PySINDy (Sparse Identification of Nonlinear Dynamics) to discover
governing equations from time-series data generated by both the ODE and SimPy models.
"""

import numpy as np
import pandas as pd
import pysindy as ps
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, r2_score


class EquationDiscovery:
    """
    PySINDy-based equation discovery for fluid queue systems.
    
    This class applies SINDy to learn the governing equations from time-series data
    and compares the discovered equations with the true underlying dynamics.
    """
    
    def __init__(self, threshold=0.01, alpha=0.05, max_iter=20):
        """
        Initialize the equation discovery system.
        
        Parameters:
        -----------
        threshold : float
            Sparsity threshold for SINDy
        alpha : float
            Regularization parameter
        max_iter : int
            Maximum iterations for SINDy optimization
        """
        self.threshold = threshold
        self.alpha = alpha
        self.max_iter = max_iter
        
        # SINDy model
        self.model = None
        
        # Discovered equations
        self.discovered_equations = None
        self.feature_names = None
        self.coefficients = None
        
        # Training data
        self.X_train = None
        self.t_train = None
        self.X_dot_train = None
        
    def prepare_data(self, data_df):
        """
        Prepare data for SINDy analysis using forward finite differences.
        
        Parameters:
        -----------
        data_df : pandas.DataFrame
            DataFrame with columns: time, x, y
            
        Returns:
        --------
        X : ndarray
            State variables [x, y] (length N-1)
        X_dot : ndarray
            Time derivatives [dx/dt, dy/dt] (length N-1)
        t : ndarray
            Time vector (length N-1)
        """
        # Sort by time to ensure proper ordering
        data_df = data_df.sort_values('time').reset_index(drop=True)
        
        t = data_df['time'].values
        X = data_df[['x', 'y']].values
        
        # Compute derivatives using forward finite differences
        dt = np.diff(t)
        dX = np.diff(X, axis=0)
        X_dot = dX / dt[:, None]
        
        # Remove last data point from X and first time to align shapes
        X = X[:-1]
        t = t[1:]
        
        # Remove NaNs that might arise just in case
        valid_indices = ~(np.isnan(X).any(axis=1) | np.isnan(X_dot).any(axis=1))
        
        return X[valid_indices], X_dot[valid_indices], t[valid_indices]
    
    def fit_sindy_model(self, X, X_dot, t=None, feature_library=None):
        """
        Fit SINDy model to the data.
        
        Parameters:
        -----------
        X : ndarray
            State variables
        X_dot : ndarray
            Time derivatives
        t : ndarray, optional
            Time vector
        feature_library : pysindy library, optional
            Feature library to use
            
        Returns:
        --------
        model : pysindy.SINDy
            Fitted SINDy model
        """
        # Default polynomial feature library
        if feature_library is None:
            feature_library = ps.PolynomialLibrary(degree=2, include_bias=True)
        
        # Create SINDy model
        self.model = ps.SINDy(
            optimizer=ps.STLSQ(threshold=self.threshold, alpha=self.alpha, 
                              max_iter=self.max_iter, verbose=False, normalize_columns=False),
            feature_library=feature_library,
            differentiation_method=ps.FiniteDifference()
        )
        
        # Fit the model
        self.model.fit(X, t=t, x_dot=X_dot)
        
        # Store training data
        self.X_train = X.copy()
        self.X_dot_train = X_dot.copy()
        self.t_train = t.copy() if t is not None else None
        
        # Extract discovered equations
        self.discovered_equations = self.model.equations()
        self.feature_names = self.model.get_feature_names()
        self.coefficients = self.model.coefficients()
        
        return self.model
    
    def predict_derivatives(self, X):
        """
        Predict derivatives using the discovered model.
        
        Parameters:
        -----------
        X : ndarray
            State variables
            
        Returns:
        --------
        X_dot_pred : ndarray
            Predicted derivatives
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        return self.model.predict(X)
    
    def simulate_discovered_system(self, initial_state, t_eval):
        """
        Simulate the system using discovered equations.
        
        Parameters:
        -----------
        initial_state : array_like
            Initial conditions [x(0), y(0)]
        t_eval : array_like
            Time points for evaluation
            
        Returns:
        --------
        solution : ndarray
            Solution of the discovered system
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        solution = self.model.simulate(initial_state, t_eval)
        return solution
    
    def compare_with_true_system(self, solution_ode, initial_state, t_eval):
        """
        Compare discovered system with true system.
        
        Parameters:
        -----------
        solution_ode : ndarray
            True system solution
        initial_state : array_like
            Initial conditions
        t_eval : array_like
            Time points for evaluation
            
        Returns:
        --------
        comparison_results : dict
            Comparison metrics and data
        """        
        # Simulate discovered system
        try:
            discovered_solution = self.simulate_discovered_system(initial_state, t_eval)
        except Exception as e:
            print(f"Warning: Could not simulate discovered system: {e}")
            discovered_solution = np.zeros_like(solution_ode)
        
        # Calculate metrics
        mse_x = mean_squared_error(solution_ode[:, 0], discovered_solution[:, 0])
        mse_y = mean_squared_error(solution_ode[:, 1], discovered_solution[:, 1])
        
        r2_x = r2_score(solution_ode[:, 0], discovered_solution[:, 0])
        r2_y = r2_score(solution_ode[:, 1], discovered_solution[:, 1])
        
        return {
            'time': t_eval,
            'true_solution': solution_ode,
            'discovered_solution': discovered_solution,
            'mse_x': mse_x,
            'mse_y': mse_y,
            'r2_x': r2_x,
            'r2_y': r2_y,
            'total_mse': mse_x + mse_y,
            'avg_r2': (r2_x + r2_y) / 2
        }
    
    def compare_with_training_data(self, X_train, t_train, time_grid):
        """
        Compare discovered system with training data.
        
        Parameters:
        -----------
        X_train : ndarray
            Training state variables
        t_train : ndarray
            Training time vector
        time_grid : ndarray
            Time points for simulation
            
        Returns:
        --------
        comparison_results : dict
            Comparison metrics and data
        """
        if self.model is None:
            raise ValueError("Model not fitted. Call fit_sindy_model first.")
        
        # Simulate discovered system from initial training state
        initial_state = X_train[0]
        discovered_solution = self.simulate_discovered_system(initial_state, time_grid)
        
        # Interpolate training data to the simulation time grid
        from scipy.interpolate import interp1d
        interp_func_x = interp1d(t_train, X_train[:, 0], kind='linear', fill_value="extrapolate")
        interp_func_y = interp1d(t_train, X_train[:, 1], kind='linear', fill_value="extrapolate")
        
        x_train_interp = interp_func_x(time_grid)
        y_train_interp = interp_func_y(time_grid)
        
        # Calculate metrics
        mse_x = mean_squared_error(x_train_interp, discovered_solution[:, 0])
        mse_y = mean_squared_error(y_train_interp, discovered_solution[:, 1])
        
        r2_x = r2_score(x_train_interp, discovered_solution[:, 0])
        r2_y = r2_score(y_train_interp, discovered_solution[:, 1])
        
        return {
            'time': time_grid,
            'training_data': np.column_stack((x_train_interp, y_train_interp)),
            'discovered_solution': discovered_solution,
            'mse_x': mse_x,
            'mse_y': mse_y,
            'r2_x': r2_x,
            'r2_y': r2_y,
            'total_mse': mse_x + mse_y,
            'avg_r2': (r2_x + r2_y) / 2
        }
